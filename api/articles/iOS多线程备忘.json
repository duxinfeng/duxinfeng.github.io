{"title":"iOS多线程备忘","uid":"973fd56e99e6965f2cb84c745d51ae34","slug":"iOS多线程备忘","date":"2016-05-26T05:48:23.000Z","updated":"2020-03-28T15:46:06.000Z","comments":true,"path":"api/articles/iOS多线程备忘.json","keywords":null,"cover":null,"content":"<h3 id=\"进程与线程\"><a href=\"#进程与线程\" class=\"headerlink\" title=\"进程与线程\"></a>进程与线程</h3><p>进程: 启动Chrome浏览器，就是启动一个进程</p>\n<p>线程：使用Chrome一遍下载一遍浏览网页，这个时候有多个线程，下载的线程和加载网页的线程. </p>\n<p>一个进程至少有一个线程，线程在进程中执行。线程中串行执行任务，同一时间只能执行一个任务。</p>\n<h3 id=\"NSThread\"><a href=\"#NSThread\" class=\"headerlink\" title=\"NSThread\"></a>NSThread</h3><p>开启一个线程进行任务处理</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">[NSThread detachNewThreadSelector:@selector(dosomething) toTarget:self withObject:nil];\n[NSThread detachNewThreadWithBlock:^&#123;\n        [self dosomething];\n    &#125;];\nNSThread *thread &#x3D; [[NSThread alloc] initWithTarget:self selector:@selector(dosomething) object:nil];\n    [thread start];\n\n<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<p>NSObject类拓展直接使用</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">[self performSelectorInBackground:@selector(dosomething) withObject:nil];\n[self performSelectorOnMainThread:@selector(dosomething) withObject:nil waitUntilDone:NO];\n[self performSelector:@selector(dosomething) withObject:nil];\n<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span></span></code></pre>\n<p>创建一个异步任务在后台执行，然后在主线程更新UI操作</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">[self performSelectorInBackground:@selector(requestData:) withObject:@&quot;https:&#x2F;&#x2F;xxx.png&quot;];\n\n\n- (void)requestData:(NSString *)urlString\n&#123;\n    NSData *data &#x3D; [NSData dataWithContentsOfURL:[NSURL URLWithString:urlString]];\n    [self performSelectorOnMainThread:@selector(updateUI:) withObject:data waitUntilDone:NO];\n&#125;\n\n- (void)updateUI:(NSData *)data\n&#123;\n    &#x2F;&#x2F; 拿到data，跟新UI\n&#125;<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n<h3 id=\"NSOperation、NSOperationQueue\"><a href=\"#NSOperation、NSOperationQueue\" class=\"headerlink\" title=\"NSOperation、NSOperationQueue\"></a>NSOperation、NSOperationQueue</h3><h3 id=\"Grand-Centeral-Dispatch\"><a href=\"#Grand-Centeral-Dispatch\" class=\"headerlink\" title=\"Grand Centeral Dispatch\"></a>Grand Centeral Dispatch</h3><h4 id=\"并行与串行\"><a href=\"#并行与串行\" class=\"headerlink\" title=\"并行与串行\"></a>并行与串行</h4><p>dispatch_get_global_queue 全局并行队列<br>dispatch_get_main_queue 主线程串行队列</p>\n<p>dispatch_sync(xxx, ^{ }) 同步线程<br>dispatch_async(xxx, ^{ }) 异步线程</p>\n<p>搭配使用   </p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">dispatch_async(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0), ^&#123;\n        &#x2F;&#x2F; 子线程中耗时操作\n        dispatch_async(dispatch_get_main_queue(), ^&#123;\n            &#x2F;&#x2F; 主线程中更新页面\n        &#125;);\n    &#125;);<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<h4 id=\"GCD单例\"><a href=\"#GCD单例\" class=\"headerlink\" title=\"GCD单例\"></a>GCD单例</h4><pre class=\"line-numbers language-none\"><code class=\"language-none\">static dispatch_once_t onceToken;\ndispatch_once(&amp;onceToken, ^&#123;\n        \n&#125;);<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span></span></code></pre>\n<p>执行一次，常用来写单例方法</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">+ (id)sharedManager &#123;\n    \n    static dispatch_once_t once;\n    \n    static id instance;\n    \n    dispatch_once(&amp;once, ^&#123;\n        \n        instance &#x3D; [[self alloc] init];\n        \n    &#125;);\n    \n    return instance;\n    \n&#125;\n<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<h4 id=\"GCD定时器\"><a href=\"#GCD定时器\" class=\"headerlink\" title=\"GCD定时器\"></a>GCD定时器</h4><pre class=\"line-numbers language-none\"><code class=\"language-none\">__block int timeout &#x3D; 3;\ndispatch_queue_t queue &#x3D; dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0);\ndispatch_source_t timer &#x3D; dispatch_source_create(DISPATCH_SOURCE_TYPE_TIMER, 0, 0,queue);\ndispatch_source_set_timer(timer,dispatch_walltime(NULL, 0),1.0*NSEC_PER_SEC, 0); &#x2F;&#x2F;每秒执行\ndispatch_source_set_event_handler(timer, ^&#123;\n    if(timeout&lt;&#x3D;0)&#123; &#x2F;&#x2F;倒计时结束，关闭\n                \n        dispatch_async(dispatch_get_main_queue(), ^&#123;\n                           \n        &#125;);\n     &#125;else&#123;\n        \n        dispatch_async(dispatch_get_main_queue(), ^&#123;           \n                    \n        &#125;);\n        timeout--;\n     &#125;\n    &#125;);\n dispatch_resume(timer);\n<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<h4 id=\"dispatch-after延后执行\"><a href=\"#dispatch-after延后执行\" class=\"headerlink\" title=\"dispatch_after延后执行\"></a>dispatch_after延后执行</h4><pre class=\"line-numbers language-none\"><code class=\"language-none\">double delayInSeconds &#x3D; 2.0;\ndispatch_time_t popTime &#x3D; dispatch_time(DISPATCH_TIME_NOW, (int64_t) (delayInSeconds * NSEC_PER_SEC));\ndispatch_after(popTime, dispatch_get_main_queue(), ^(void)&#123;\n    &#x2F;&#x2F; 两秒后执行\n&#125;);<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<h4 id=\"Dispatch-Group\"><a href=\"#Dispatch-Group\" class=\"headerlink\" title=\"Dispatch Group\"></a>Dispatch Group</h4><p>有时候一个页面需要发多个请求，待所以请求完毕，再去更新数据</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">dispatch_queue_t queue &#x3D; dispatch_queue_create(DISPATCH_QUEUE_PRIORITY_DEFAULT,0);\ndispatch_group_t group &#x3D; dispatch_group_create();\ndispatch_group_async(group, queue, ^&#123;\n    NSLog(@&quot;111&quot;);\n&#125;);\n\ndispatch_group_async(group, queue, ^&#123;\n    NSLog(@&quot;222&quot;);\n&#125;);\n   \ndispatch_group_async(group, queue, ^&#123;\n    NSLog(@&quot;333&quot;);\n&#125;);\n   \ndispatch_group_notify(group, dispatch_get_main_queue(), ^&#123;\n    NSLog(@&quot;done&quot;);\n&#125;);\n   \n&#x2F;* dispatch_group_notify 也可以换成下面dispatch_group_wait 等待上面执行完毕再往下执行*&#x2F;\n&#x2F;&#x2F;dispatch_group_wait(group, DISPATCH_TIME_FOREVER);\n&#x2F;&#x2F;NSLog(@&quot;done&quot;);<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>","text":"进程与线程进程: 启动Chrome浏览器，就是启动一个进程 线程：使用Chrome一遍下载一遍浏览网页，这个时候有多个线程，下载的线程和加载网页的线程. 一个进程至少有一个线程，线程在进程中执行。线程中串行执行任务，同一时间只能执行一个任务。 NSThread开启一个线程进行任务...","link":"","photos":[],"count_time":{"symbolsCount":"3.7k","symbolsTime":"3 mins."},"categories":[{"name":"iOS","slug":"iOS","count":37,"path":"api/categories/iOS.json"}],"tags":[{"name":"NSThread","slug":"NSThread","count":1,"path":"api/tags/NSThread.json"},{"name":"NSOperation","slug":"NSOperation","count":1,"path":"api/tags/NSOperation.json"},{"name":"Grand Centeral Dispatch","slug":"Grand-Centeral-Dispatch","count":1,"path":"api/tags/Grand-Centeral-Dispatch.json"}],"toc":"<ol class=\"toc\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E8%BF%9B%E7%A8%8B%E4%B8%8E%E7%BA%BF%E7%A8%8B\"><span class=\"toc-text\">进程与线程</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#NSThread\"><span class=\"toc-text\">NSThread</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#NSOperation%E3%80%81NSOperationQueue\"><span class=\"toc-text\">NSOperation、NSOperationQueue</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#Grand-Centeral-Dispatch\"><span class=\"toc-text\">Grand Centeral Dispatch</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E5%B9%B6%E8%A1%8C%E4%B8%8E%E4%B8%B2%E8%A1%8C\"><span class=\"toc-text\">并行与串行</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#GCD%E5%8D%95%E4%BE%8B\"><span class=\"toc-text\">GCD单例</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#GCD%E5%AE%9A%E6%97%B6%E5%99%A8\"><span class=\"toc-text\">GCD定时器</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#dispatch-after%E5%BB%B6%E5%90%8E%E6%89%A7%E8%A1%8C\"><span class=\"toc-text\">dispatch_after延后执行</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#Dispatch-Group\"><span class=\"toc-text\">Dispatch Group</span></a></li></ol></li></ol>","author":{"name":"新风作浪","slug":"blog-author","avatar":"http://qiniu.niuxtech.cn/avatar.png","link":"/","description":"专注于你能控制的","socials":{"github":"https://github.com/duxinfeng","twitter":"https://twitter.com/iduxinfeng","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"https://blog.csdn.net/duxinfeng2010","juejin":"","customs":{}}},"mapped":true,"prev_post":{"title":"貌似很有道理","uid":"dcfb890dedbf32cd06db579b02756564","slug":"貌似很有道理","date":"2017-01-02T04:34:05.000Z","updated":"2020-03-11T15:34:02.000Z","comments":true,"path":"api/articles/貌似很有道理.json","keywords":null,"cover":null,"text":"1、如果有一天： 你不再寻找爱情，只是去爱；你不再渴望成功，只是去做； 你不再追求成长，只是去修；一切才真正开始！ 2、如果不能在一起，就不要给对方任何希望任何暗示，这才是最大的担当；分开了，不去打搅让对方安然生活，这才是最后的温柔。 3、不要去听别人的忽悠，你人生的每一步都必须...","link":"","photos":[],"count_time":{"symbolsCount":342,"symbolsTime":"1 mins."},"categories":[{"name":"生活","slug":"生活","count":13,"path":"api/categories/生活.json"}],"tags":[{"name":"复盘","slug":"复盘","count":7,"path":"api/tags/复盘.json"},{"name":"摘录","slug":"摘录","count":1,"path":"api/tags/摘录.json"}],"author":{"name":"新风作浪","slug":"blog-author","avatar":"http://qiniu.niuxtech.cn/avatar.png","link":"/","description":"专注于你能控制的","socials":{"github":"https://github.com/duxinfeng","twitter":"https://twitter.com/iduxinfeng","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"https://blog.csdn.net/duxinfeng2010","juejin":"","customs":{}}}},"next_post":{"title":"An error occurred while processing the post-install hook of the Podfile.","uid":"7fad2ec65179629b5ab7e8fc0745bd39","slug":"An-error-occurred-while-processing-the-post-install-hook-of-the-Podfile","date":"2016-04-11T05:38:42.000Z","updated":"2017-04-27T12:05:47.000Z","comments":true,"path":"api/articles/An-error-occurred-while-processing-the-post-install-hook-of-the-Podfile.json","keywords":null,"cover":[],"text":"执行Pod install 报错： An error occurred while processing the post-install hook of the Podfile. undefined method `project’ for #Pod::Installer:0x...","link":"","photos":[],"count_time":{"symbolsCount":201,"symbolsTime":"1 mins."},"categories":[{"name":"iOS","slug":"iOS","count":37,"path":"api/categories/iOS.json"}],"tags":[{"name":"CocoaPods","slug":"CocoaPods","count":2,"path":"api/tags/CocoaPods.json"}],"author":{"name":"新风作浪","slug":"blog-author","avatar":"http://qiniu.niuxtech.cn/avatar.png","link":"/","description":"专注于你能控制的","socials":{"github":"https://github.com/duxinfeng","twitter":"https://twitter.com/iduxinfeng","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"https://blog.csdn.net/duxinfeng2010","juejin":"","customs":{}}}}}